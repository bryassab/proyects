// BIBLIOTECAS //

#include "mbed.h"
#include "math.h"

// ESCLAVOS INDIRECTOS

#define MPU9250_address 0xD0// 7 bit i2c Enderego da MPU9250 (giroscOpio e acelerometro) // Escalas do girOscopio 
#define MAG_ADDRESS_AK8963 0X18

//

#define GYRO_FULL_SCALE_250_DPS 0x00 // SCALE 250 (./s) = 0 (0x00 = 0001001000) 
#define GYRO_FULL_SCALE_500_DPS 0x08 // SCALE _500 (0/3) = 1 (0x08 = 0001011000) 
#define GYRO_FULL_SCALE_1000_DPS 0x10 // SCALE _1000 ('/s) = 2 (0x10 = 0001101000)
#define GYRO_FULL_SCALE_2000_DPS 0x18 // Escalas GYRO_FULL_SCALE_2000_DPS do acelerometro Ox18 

// SCALE _2000 (Â°is) = 3 (Ox18 = 0001111000)

#define ACC_FULL_SCALE_2_G 0x00 // SCALE_ 2_G (g) = 0 (0x00 = 0001001000) 
#define ACC_FULL_SCALE_4_G 0x08 // SCALE_ 4_G (g) = 1 (0x08 = 0001011000) 
#define ACC_FULL_SCALE_8_G 0x10 // SCALE_ 8_G (g) = 2 (0x10 = 0001101000) 
#define ACC_FULL_SCALE_16_G 0x18 // SCALE_ 16_G (g) = 3 (0x18 = 0001111000) 

// Escalas de conversion

#define SENSITIVITY_ACCEL       2.0/32768.0
#define SENSITIVITY_GYRO        250.0/32768.0
#define SENSITIVITY_TEMP        333.87
#define TEMP_OFFSET             21
#define SENSITIVITY_mag        (10.0*4800.0)/32768.0

//Declaracion de variables
//Raw Tipo entero

int16_t raw_accelx, raw_accely, raw_accelz;
int16_t raw_gyrox, raw_gyroy, raw_gyroz;
int16_t raw_magx, raw_magy, raw_magz;
int16_t raw_temp;

//Tipo float "Salidas calibradas"
float accelx, accely, accelz;
float gyrox, gyroy, gyroz;
float magx, magy, magz;
float temp;

//Bytes
char cmd[2];
char data[1];
char GirAcel[14];
char mag[7];

float buffer[500][8];
int i;
Timer t;
float timer=0;

Serial pc(SERIAL_TX, SERIAL_RX);
I2C i2c(PB_9, PB_8);

int main()
{
    // Desativa modo de hibernacion de MPU9250
    cmd[0] = 0x6B;
    cmd[1] = 0x00;
    i2c.write(MPU9250_address, cmd, 2);

    pc.printf("TEST PARA GIROSCOPIO, ACELEROMETRO, MAGETOMETRO\n\r");
//
// Quem sou eu para a MPU9250 (giroscOpio e acelerOmetro)
//
    pc.printf("Test conexion MPU9250... \n\r"); // Verifica a conexao
    cmd[0] = 0x75;
    i2c.write(MPU9250_address, cmd, 1);
    i2c.read(MPU9250_address, data, 1);
    if (data[0] != 0x73) { // DEFAOLT_REGISTER WHO AM I MPU9250 0x68
        pc.printf("Erro de conexion con MPU9250 \n\r");
        pc.printf("UPS_No_soy_el_MPU9250_quien_soy:S. I am: %#x \n\r",data[0]);
        pc.printf("\n\r");
        while(1);
    } else {
        pc.printf("conectado a la MPU \n\r");
        pc.printf("Soy la MPU :S. I am: %#x \n\r", data[0]);
        pc.printf("\n\r" );
    }
    wait(0.1);


// desactiva el modo de hibernacion de AK8963

    cmd[0] = 0x37;
    cmd[1] = 0x02;

    i2c.write(MPU9250_address, cmd, 2);

// configuracion de magometro AK8963

    cmd[0] = 0x0A;
    cmd[1] = 0x16;
    i2c.write(MAG_ADDRESS_AK8963,  cmd, 2);
    cmd[0]=0x00;
    i2c.write(MAG_ADDRESS_AK8963,  cmd, 1);
    i2c.read(MAG_ADDRESS_AK8963, data, 1);

    if (data[0] != 0x48) { // DEFAOLT_REGISTER WHO AM I MPU9250 0x68
        pc.printf("Error de conexion AK8963\n\r");
        pc.printf("no soy AK8963, quien soy yo? :S. I am: %#x \n\r",data[0]);
        pc.printf("\n\r");
        while(1);
    } else {
        pc.printf("conectado a la AK8963 \n\r");
        pc.printf("Soy la AK8963 :S. I am: %#x \n\r", data[0]);
        pc.printf("\n\r" );
    }
    wait(0.1);


   while(1) {
        if(pc.readable()) {
            if(pc.getc() == 'H') {
                i = 1;
                while(1) {
                    for(i=0; i<150; i++) {
                    cmd[0]=0x3B;
                    t.reset();
                    t.start();
                    i2c.write(MPU9250_address, cmd, 1);
                    i2c.read(MPU9250_address, GirAcel, 14);
                    raw_accelx = GirAcel[0]<<8 | GirAcel[1];
                    raw_accely = GirAcel[2]<<8 | GirAcel[3];
                    raw_accelz = GirAcel[4]<<8 | GirAcel[5];
                    raw_temp = GirAcel[6]<<8 | GirAcel[7];
                    raw_gyrox = GirAcel[8]<<8 | GirAcel[9];
                    raw_gyroy = GirAcel[10]<<8 | GirAcel[11];
                    raw_gyroz = GirAcel[12]<<8 | GirAcel[13];
                    
                     
                    
                  cmd[0]=0x02; //AK8963_ST1        0x02   
                i2c.write(MAG_ADDRESS_AK8963, cmd, 1);
                i2c.read(MAG_ADDRESS_AK8963, data, 1);

                if (data[0]&0x01 == 0x01) {
                    cmd[0]=0x03;   // AK8963_XOUT_L     0x03   // datos
                    i2c.write(MAG_ADDRESS_AK8963, cmd, 1);
                    i2c.read(MAG_ADDRESS_AK8963, mag, 7);
                    if(!(mag[6]&0x08)) {
                        raw_magx=mag[1]<<8| mag[0];  
                        raw_magy=mag[3]<<8| mag[2];  
                        raw_magz=mag[5]<<8| mag[4];
                    }
                }

                accelx = raw_accelx*SENSITIVITY_ACCEL;
                accely = raw_accely*SENSITIVITY_ACCEL;
                accelz = raw_accelz*SENSITIVITY_ACCEL;
                magx=raw_magx*SENSITIVITY_mag;
                magy=raw_magy*SENSITIVITY_mag;
                magz=raw_magz*SENSITIVITY_mag*-1;
                 //magx=raw_magx;
                //magy=raw_magy;
                //magz=raw_magz*-1;
                wait_ms(9);
                wait_us(962);
                
                t.stop();
                timer = t.read();
                // pc.printf("El tiempo es %f segundos \r",timer);
                pc.printf("%d,%.2f,%.2f,%.2f \n\r",i+1, magy, magx, magz);

                }
            }
        }
    }
}
}
