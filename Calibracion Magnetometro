// BIBLIOTECAS //

#include "mbed.h"
#include "math.h"

// ESCLAVOS INDIRECTOS

#define MPU9250_address 0xD0// 7 bit i2c Enderego da MPU9250 (giroscOpio e acelerometro) // Escalas do girOscopio 
#define MAG_ADDRESS_AK8963 0X18

//

#define GYRO_FULL_SCALE_250_DPS 0x00 // SCALE 250 (./s) = 0 (0x00 = 0001001000) 
#define GYRO_FULL_SCALE_500_DPS 0x08 // SCALE _500 (0/3) = 1 (0x08 = 0001011000) 
#define GYRO_FULL_SCALE_1000_DPS 0x10 // SCALE _1000 ('/s) = 2 (0x10 = 0001101000)
#define GYRO_FULL_SCALE_2000_DPS 0x18 // Escalas GYRO_FULL_SCALE_2000_DPS do acelerometro Ox18 

// SCALE _2000 (Â°is) = 3 (Ox18 = 0001111000)

#define ACC_FULL_SCALE_2_G 0x00 // SCALE_ 2_G (g) = 0 (0x00 = 0001001000) 
#define ACC_FULL_SCALE_4_G 0x08 // SCALE_ 4_G (g) = 1 (0x08 = 0001011000) 
#define ACC_FULL_SCALE_8_G 0x10 // SCALE_ 8_G (g) = 2 (0x10 = 0001101000) 
#define ACC_FULL_SCALE_16_G 0x18 // SCALE_ 16_G (g) = 3 (0x18 = 0001111000) 

// Escalas de conversion

#define SENSITIVITY_ACCEL       2.0/32768.0
#define SENSITIVITY_GYRO        250.0/32768.0
#define SENSITIVITY_TEMP        333.87
#define TEMP_OFFSET             21
#define SENSITIVITY_mag        (10.0*4800.0)/32768.0

//Declaracion de variables
//Raw Tipo entero

int16_t raw_accelx, raw_accely, raw_accelz;
int16_t raw_gyrox, raw_gyroy, raw_gyroz;
int16_t raw_magx, raw_magy, raw_magz;
int16_t raw_temp;

//valores de offsets de tipo float
float offset_accelx = 0.0, offset_accely = 0.0, offset_accelz = 0.0;
float offset_gyrox = 0.0, offset_gyroy = 0.0, offset_gyroz = 0.0;
float offset_magx = 0.0, offset_magy = 0.0, offset_magz = 0.0;


//maximos y minimos para los offsets
float max_accelx = -32768.0, min_accelx = 32768.0, max_accely = -32768.0, min_accely = 32768.0, max_accelz = -32768.0, min_accelz = 32768.0;
float max_gyrox = -32768.0, min_gyrox = 32768.0, max_gyroy = -32768.0, min_gyroy = 32768.0, max_gyroz = -32768.0, min_gyroz = 32768.0;
float max_magx = -32768.0, min_magx = 32768.0, max_magy = -32768.0, min_magy = 32768.0, max_magz = -32768.0, min_magz = 32768.0;


//Tipo float "Salidas calibradas"
float accelx, accely, accelz;
float gyrox, gyroy, gyroz;
float magx, magy, magz;
float temp;

//Bytes
char cmd[2];
char data[1];
char GirAcel[14];
char mag[7];

float buffer[500][8];
int i,offset_samples = 500;
Timer t;
float timer=0;

Serial pc(SERIAL_TX, SERIAL_RX);
I2C i2c(PB_9, PB_8);

int main()
{
    // Desativa modo de hibernacion de MPU9250
    cmd[0] = 0x6B;
    cmd[1] = 0x00;
    i2c.write(MPU9250_address, cmd, 2);

    pc.printf("TEST PARA GIROSCOPIO, ACELEROMETRO, MAGETOMETRO\n\r");
//
// Quem sou eu para a MPU9250 (giroscOpio e acelerOmetro)
//
    pc.printf("Test conexion MPU9250... \n\r"); // Verifica a conexao
    cmd[0] = 0x75;
    i2c.write(MPU9250_address, cmd, 1);
    i2c.read(MPU9250_address, data, 1);
    if (data[0] != 0x73) { // DEFAOLT_REGISTER WHO AM I MPU9250 0x68
        pc.printf("Erro de conexion con MPU9250 \n\r");
        pc.printf("UPS_No_soy_el_MPU9250_quien_soy:S. I am: %#x \n\r",data[0]);
        pc.printf("\n\r");
        while(1);
    } else {
        pc.printf("conectado a la MPU \n\r");
        pc.printf("Soy la MPU :S. I am: %#x \n\r", data[0]);
        pc.printf("\n\r" );
    }
    wait(0.1);


// desactiva el modo de hibernacion de AK8963

    cmd[0] = 0x37;
    cmd[1] = 0x02;

    i2c.write(MPU9250_address, cmd, 2);

// configuracion de magometro AK8963

    cmd[0] = 0x0A;
    cmd[1] = 0x16;
    i2c.write(MAG_ADDRESS_AK8963,  cmd, 2);
    cmd[0]=0x00;
    i2c.write(MAG_ADDRESS_AK8963,  cmd, 1);
    i2c.read(MAG_ADDRESS_AK8963, data, 1);

    if (data[0] != 0x48) { // DEFAOLT_REGISTER WHO AM I MPU9250 0x68
        pc.printf("Error de conexion AK8963\n\r");
        pc.printf("no soy AK8963, quien soy yo? :S. I am: %#x \n\r",data[0]);
        pc.printf("\n\r");
        while(1);
    } else {
        pc.printf("conectado a la AK8963 \n\r");
        pc.printf("Soy la AK8963 :S. I am: %#x \n\r", data[0]);
        pc.printf("\n\r" );
    }
    wait(0.1);

      //calibraciosn del giroscopio y acelerometro

   while(1) {
        pc.printf("calibracion del magnetometro \n\r");
        wait(2);
        pc.printf("coloque la imu en una posicion horizontal prependicular al eje z \n\r ");
        wait(2);
        pc.printf("leyendo los sensores por primera vez...\n\r");
        for(i=0; i<offset_samples; i++){
                   cmd[0]=0x02; //AK8963_ST1        0x02   
                i2c.write(MAG_ADDRESS_AK8963, cmd, 1);
                i2c.read(MAG_ADDRESS_AK8963, data, 1);

                if (data[0]&0x01 == 0x01) {
                    cmd[0]=0x03;   // AK8963_XOUT_L     0x03   // datos
                    i2c.write(MAG_ADDRESS_AK8963, cmd, 1);
                    i2c.read(MAG_ADDRESS_AK8963, mag, 7);
                    if(!(mag[6]&0x08)) {
                        raw_magx=mag[1]<<8| mag[0];  
                        raw_magy=mag[3]<<8| mag[2];  
                        raw_magz=mag[5]<<8| mag[4];
                    }
                }
                    wait(0.02);     
                   }
                pc.printf("leyendo los sensores y calculando los offsets de x y... \n\r");
                wait(0.03);
                  for(i=0; i<offset_samples; i++){
                     cmd[0]=0x02; //AK8963_ST1        0x02   
                i2c.write(MAG_ADDRESS_AK8963, cmd, 1);
                i2c.read(MAG_ADDRESS_AK8963, data, 1);

                if (data[0]&0x01 == 0x01) {
                    cmd[0]=0x03;   // AK8963_XOUT_L     0x03   // datos
                    i2c.write(MAG_ADDRESS_AK8963, cmd, 1);
                    i2c.read(MAG_ADDRESS_AK8963, mag, 7);
                    if(!(mag[6]&0x08)) {
                        raw_magx=mag[1]<<8| mag[0];  
                        raw_magy=mag[3]<<8| mag[2];  
                        raw_magz=mag[5]<<8| mag[4];
                    }
                    //maximos y minimos para el acelerometro 
                    // eje x
                  if(raw_magx >= max_magx){
                    max_magx = raw_magx;
                    } 
                  if(raw_magx <= min_magx){
                    min_magx = raw_magx;
                    }
                    // eje y
                  if(raw_magy >= max_magy){
                    max_magy = raw_magy;
                    }    
                  if(raw_magy <= min_magy){
                    min_magy = raw_magy;
                    } 
                 
                    
                   
                    wait(0.03);
                    }
                    }
                      pc.printf("leyendo los sensores y calculando los offsets z... \n\r");
                      wait(0.1);
            pc.printf("coloque la imu en una posicion letra mirandome \n\r ");
            wait(0.1);
            pc.printf("coloque la imu en una posicion 2 y girela para saber el offset del eje z\n\r ");
            wait(0.1);
            for(i=0; i<offset_samples; i++) {
                cmd[0]=0x02; //AK8963_ST1        0x02
                i2c.write(MAG_ADDRESS_AK8963, cmd, 1);
                i2c.read(MAG_ADDRESS_AK8963, data, 1);

                if (data[0]&0x01 == 0x01) {
                    cmd[0]=0x03;   // AK8963_XOUT_L     0x03   // datos
                    i2c.write(MAG_ADDRESS_AK8963, cmd, 1);
                    i2c.read(MAG_ADDRESS_AK8963, mag, 7);
                    if(!(mag[6]&0x08)) {
                        raw_magx=mag[1]<<8| mag[0];
                        raw_magy=mag[3]<<8| mag[2];
                        raw_magz=mag[5]<<8| mag[4];
                    }
                    //maximos y minimos para el acelerometro
                    // eje x
                    if(raw_magz >= max_magz) {
                        max_magz = raw_magz;
                    }
                    if(raw_magz <= min_magz) {
                        min_magz = raw_magz;
                    }

                    wait(0.05);
                }
                }
                  
                  //giroscopio
                    offset_magx = (max_magx + min_magx)/2;
                    offset_magy = (max_magy + min_magy)/2;
                    offset_magz = (max_magz + min_magz)/2;
                    
                    pc.printf("calibracion finalizada del magnetometro \n\r");
                    pc.printf("offset_magx = %.2f, offset_magly = %.2f, offset_magz = %.2f \n\r ",offset_magx, offset_magy, offset_magz);
                    pc.printf("calibracion finalizada");
                    wait(100);
                    
            
        
        
        }
        }
